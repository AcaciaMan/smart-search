/**
 * Solr Query Builder End-to-End Integration Tests
 *
 * Verifies that queries generated by `SolrQueryBuilder` execute successfully
 * against a live Solr instance and return expected results. Complements the
 * existing unit tests by proving the generated syntax is valid Solr query
 * language.
 *
 * Requires a live Solr server — all tests are skipped when Solr is unreachable.
 */

import * as assert from 'assert';
import axios from 'axios';
import {
  skipIfSolrUnavailable,
  getSolrCoreUrl,
  seedDocuments,
  deleteByQuery,
  waitForCommit,
} from './testHelpers';
import {
  TEST_TIMEOUT,
  TEST_QUERY_PREFIX,
} from './constants';
import { createTestDocument, generateTestMarker } from './testDataFactory';
import { SolrQueryBuilder } from '../../../services/solrQueryBuilder';

suite('Solr Query Builder Integration Tests', function () {
  this.timeout(TEST_TIMEOUT);

  let builder: SolrQueryBuilder;
  let testMarker: string;
  let coreUrl: string;
  let sessionId: string;

  /** Execute a Solr query built by the builder and return docs */
  async function execQuery(
    q: string,
    extraParams?: Record<string, any>,
  ): Promise<any[]> {
    const response = await axios.get(`${coreUrl}/search`, {
      params: {
        q,
        fq: `search_session_id:${sessionId}`,
        wt: 'json',
        rows: 100,
        fl: '*,score',
        ...extraParams,
      },
      timeout: 10000,
    });
    return response.data.response.docs;
  }

  // -----------------------------------------------------------------------
  // Seed data
  // -----------------------------------------------------------------------

  suiteSetup(async function () {
    this.timeout(30000);
    await skipIfSolrUnavailable(this);

    builder = new SolrQueryBuilder();
    testMarker = generateTestMarker('querybuilder');
    coreUrl = getSolrCoreUrl();
    sessionId = `session_qb_integration_${Date.now()}`;

    const docs = [
      // JavaScript code
      createTestDocument({
        id: `qb_test_1_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: 'function calculateTotal(items, tax)',
        full_line: '  export function calculateTotal(items, tax) {',
        display_content: '// calc\n>>> export function calculateTotal(items, tax) { <<<\n  return sum;',
        file_name: 'calculator.js',
        file_extension: 'js',
        file_path: '/src/calculator.js',
        line_number: 10,
      }),
      // TypeScript interface
      createTestDocument({
        id: `qb_test_2_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: 'interface SearchOptions',
        full_line: 'export interface SearchOptions {',
        display_content: '// types\n>>> export interface SearchOptions { <<<\n  query: string;',
        file_name: 'types.ts',
        file_extension: 'ts',
        file_path: '/src/types/index.ts',
        line_number: 1,
      }),
      // Config file
      createTestDocument({
        id: `qb_test_3_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: '"name": "smart-search"',
        full_line: '  "name": "smart-search",',
        display_content: '{\n>>> "name": "smart-search", <<<\n  "version": "1.0"',
        file_name: 'package.json',
        file_extension: 'json',
        file_path: '/package.json',
        line_number: 3,
      }),
      // Python code
      createTestDocument({
        id: `qb_test_4_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: 'def process_data(self, items):',
        full_line: '    def process_data(self, items):',
        display_content: '# processing\n>>> def process_data(self, items): <<<\n  return data',
        file_name: 'processor.py',
        file_extension: 'py',
        file_path: '/src/processor.py',
        line_number: 10,
      }),
      // Special characters
      createTestDocument({
        id: `qb_test_5_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: 'price = items.reduce((a, b) => a + b)',
        full_line: 'const price = items.reduce((a, b) => a + b, 0);',
        display_content: '// sum\n>>> const price = items.reduce((a, b) => a + b, 0); <<<\n  return price;',
        file_name: 'utils.ts',
        file_extension: 'ts',
        file_path: '/src/utils.ts',
        line_number: 20,
      }),
      // Case-sensitive + whole-word doc
      createTestDocument({
        id: `qb_test_6_${Date.now()}`,
        search_session_id: sessionId,
        original_query: testMarker,
        match_text: 'CaseSensitiveFunction',
        full_line: 'export function CaseSensitiveFunction() {}',
        display_content: '>>> export function CaseSensitiveFunction() {} <<<',
        file_name: 'case.ts',
        file_extension: 'ts',
        file_path: '/src/case.ts',
        line_number: 1,
        case_sensitive: true,
        whole_word: true,
      }),
    ];

    await seedDocuments(docs);
  });

  suiteTeardown(async function () {
    this.timeout(30000);
    await deleteByQuery(`original_query:"${testMarker}"`);
  });

  // -----------------------------------------------------------------------
  // 1. Simple Word Query
  // -----------------------------------------------------------------------

  test('Simple word query finds matching document', async () => {
    const q = builder.buildSolrQuery('calculateTotal');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'Should find at least 1 result');
    const matchTexts = docs.map((d: any) =>
      Array.isArray(d.match_text) ? d.match_text[0] : d.match_text,
    );
    assert.ok(
      matchTexts.some((m: string) => m.includes('calculateTotal')),
      'Should find the calculateTotal document',
    );
  });

  // -----------------------------------------------------------------------
  // 2. Field-Specific Query
  // -----------------------------------------------------------------------

  test('Field-specific query file_name:package.json returns only that file', async () => {
    const q = builder.buildSolrQuery('file_name:package.json');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'Should find package.json');
    for (const doc of docs) {
      const fn = Array.isArray(doc.file_name) ? doc.file_name[0] : doc.file_name;
      assert.strictEqual(fn, 'package.json', `Expected package.json, got ${fn}`);
    }
  });

  // -----------------------------------------------------------------------
  // 3. File Extension Query
  // -----------------------------------------------------------------------

  test('file_extension:py returns only Python files', async () => {
    const q = builder.buildSolrQuery('file_extension:py');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'Should find Python files');
    for (const doc of docs) {
      const ext = Array.isArray(doc.file_extension) ? doc.file_extension[0] : doc.file_extension;
      assert.strictEqual(ext, 'py', `Expected py extension, got ${ext}`);
    }
  });

  // -----------------------------------------------------------------------
  // 4. Filename-Like Query Routing
  // -----------------------------------------------------------------------

  test('Filename-like query routes to file_name/file_path', async () => {
    const q = builder.buildSolrQuery('calculator.js');

    // Verify routing
    assert.ok(
      q.includes('file_name') || q.includes('file_path'),
      `Query should route to file_name/file_path, got: "${q}"`,
    );

    const docs = await execQuery(q);
    assert.ok(docs.length >= 1, 'Should find calculator.js');
    assert.ok(
      docs.some((d: any) => {
        const fn = Array.isArray(d.file_name) ? d.file_name[0] : d.file_name;
        return fn === 'calculator.js';
      }),
      'Should match calculator.js by filename',
    );
  });

  // -----------------------------------------------------------------------
  // 5. Code Pattern Query Routing
  // -----------------------------------------------------------------------

  test('Code pattern query includes code_all boost', async () => {
    const q = builder.buildSolrQuery('function calculateTotal');

    assert.ok(
      q.includes('code_all'),
      `Code query should target code_all, got: "${q}"`,
    );

    const docs = await execQuery(q);
    assert.ok(docs.length >= 1, 'Should find function results');
  });

  // -----------------------------------------------------------------------
  // 6. Boolean AND Query
  // -----------------------------------------------------------------------

  test('Boolean AND query narrows results', async () => {
    // "interface" AND "SearchOptions" — should match qb_test_2
    const q = builder.buildSolrQuery('interface AND SearchOptions');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'AND query should return results');
  });

  // -----------------------------------------------------------------------
  // 7. Boolean OR Query
  // -----------------------------------------------------------------------

  test('Boolean OR query broadens results', async () => {
    const q = builder.buildSolrQuery('calculateTotal OR process_data');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 2, `OR query should return at least 2 results, got ${docs.length}`);
  });

  // -----------------------------------------------------------------------
  // 8. Wildcard Query
  // -----------------------------------------------------------------------

  test('Wildcard query calculate* matches calculateTotal', async () => {
    const q = builder.buildSolrQuery('match_text:calculate*');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'Wildcard query should return results');
    const matchTexts = docs.map((d: any) =>
      Array.isArray(d.match_text) ? d.match_text[0] : d.match_text,
    );
    assert.ok(
      matchTexts.some((m: string) => m.toLowerCase().includes('calculatetotal')),
      'Should find calculateTotal via wildcard',
    );
  });

  // -----------------------------------------------------------------------
  // 9. Quoted Phrase Query
  // -----------------------------------------------------------------------

  test('Quoted phrase query returns exact match', async () => {
    const q = builder.buildSolrQuery('match_text:"process_data"');
    const docs = await execQuery(q);

    assert.ok(docs.length >= 1, 'Phrase query should return results');
  });

  // -----------------------------------------------------------------------
  // 10. Special Characters Escaped
  // -----------------------------------------------------------------------

  test('Special characters are properly escaped and do not cause Solr errors', async () => {
    const sanitized = builder.sanitizeQuery('(a + b)');
    assert.ok(sanitized.length > 0, 'Sanitized query should not be empty');

    // Execute — should NOT throw a 400 parse error
    const q = builder.buildSolrQuery('(a + b)');
    const docs = await execQuery(q);
    // We just verify it doesn't throw; results may or may not match
    assert.ok(Array.isArray(docs), 'Should return an array (no parse error)');
  });

  // -----------------------------------------------------------------------
  // 11. buildSearchParams with maxResults
  // -----------------------------------------------------------------------

  test('buildSearchParams respects maxResults', async () => {
    const params = builder.buildSearchParams(
      { query: 'items', maxResults: 2 },
      sessionId,
    );

    assert.strictEqual(params.rows, 2, 'rows should be 2');

    const response = await axios.get(`${coreUrl}/search`, {
      params: { ...params, wt: 'json' },
      timeout: 10000,
    });

    assert.ok(
      response.data.response.docs.length <= 2,
      `Should return at most 2 results, got ${response.data.response.docs.length}`,
    );
  });

  // -----------------------------------------------------------------------
  // 12. buildSearchParams with Session Filter
  // -----------------------------------------------------------------------

  test('buildSearchParams includes session fq', async () => {
    const params = builder.buildSearchParams(
      { query: '*:*' },
      sessionId,
    );

    assert.ok(
      params.fq && params.fq.includes(sessionId),
      `fq should contain session ID, got: "${params.fq}"`,
    );

    const response = await axios.get(`${coreUrl}/search`, {
      params: { ...params, wt: 'json' },
      timeout: 10000,
    });

    for (const doc of response.data.response.docs) {
      const sid = Array.isArray(doc.search_session_id)
        ? doc.search_session_id[0]
        : doc.search_session_id;
      assert.strictEqual(sid, sessionId, 'All results should be from the test session');
    }
  });

  // -----------------------------------------------------------------------
  // 13. buildSearchParams with Combined Filters
  // -----------------------------------------------------------------------

  test('buildSearchParams combines session + caseSensitive + wholeWord in fq', async () => {
    const params = builder.buildSearchParams(
      { query: '*:*', caseSensitive: true, wholeWord: true },
      sessionId,
    );

    assert.ok(params.fq, 'fq should be set');
    assert.ok(params.fq.includes('AND'), 'fq should use AND to combine filters');
    assert.ok(params.fq.includes(sessionId), 'fq should include session ID');
    assert.ok(params.fq.includes('case_sensitive:true'), 'fq should include case_sensitive');
    assert.ok(params.fq.includes('whole_word:true'), 'fq should include whole_word');

    // Execute — should not cause a Solr error
    const response = await axios.get(`${coreUrl}/search`, {
      params: { ...params, wt: 'json' },
      timeout: 10000,
    });
    assert.ok(Array.isArray(response.data.response.docs), 'Should return docs array');
  });

  // -----------------------------------------------------------------------
  // 14. Empty Query → *:*
  // -----------------------------------------------------------------------

  test('Empty query returns *:* and finds all docs', async () => {
    const q = builder.buildSolrQuery('');
    assert.strictEqual(q, '*:*', 'Empty query should produce *:*');

    const docs = await execQuery(q);
    assert.ok(docs.length >= 5, `Should return all seeded docs, got ${docs.length}`);
  });

  // -----------------------------------------------------------------------
  // 15. maxResults Cap at 10,000
  // -----------------------------------------------------------------------

  test('maxResults is capped at 10000', () => {
    const params = builder.buildSearchParams(
      { query: 'test', maxResults: 50000 },
    );

    assert.ok(
      params.rows <= 10000,
      `rows should be capped at 10000, got ${params.rows}`,
    );
  });

  // -----------------------------------------------------------------------
  // 16. Sort Order — score desc
  // -----------------------------------------------------------------------

  test('Results are sorted by score descending', async () => {
    const params = builder.buildSearchParams(
      { query: 'items' },
      sessionId,
    );

    assert.ok(
      params.sort && params.sort.includes('score desc'),
      `sort should include "score desc", got: "${params.sort}"`,
    );

    const response = await axios.get(`${coreUrl}/search`, {
      params: { ...params, wt: 'json' },
      timeout: 10000,
    });

    const docs = response.data.response.docs;
    if (docs.length >= 2) {
      for (let i = 1; i < docs.length; i++) {
        assert.ok(
          docs[i - 1].score >= docs[i].score,
          `Score at index ${i - 1} (${docs[i - 1].score}) should be >= score at ${i} (${docs[i].score})`,
        );
      }
    }
  });

  // -----------------------------------------------------------------------
  // 17. Malformed Query Error Handling
  // -----------------------------------------------------------------------

  test('Malformed query to Solr is handled gracefully', async () => {
    try {
      await axios.get(`${coreUrl}/search`, {
        params: {
          q: '[[[ unbalanced {{{',
          wt: 'json',
        },
        timeout: 10000,
      });
      // If Solr doesn't throw, that's fine too
    } catch (error: any) {
      // Expect a 400 from Solr
      if (error.response) {
        assert.strictEqual(
          error.response.status,
          400,
          `Expected 400 Bad Request, got ${error.response.status}`,
        );
      } else {
        // Network error or timeout is also acceptable
        assert.ok(error.message, 'Should have an error message');
      }
    }
  });
});
